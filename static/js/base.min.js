(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };

  // src/js/components/overlay.js
  var Overlay, OverlayFactory;
  var init_overlay = __esm({
    "src/js/components/overlay.js"() {
      Overlay = class {
        /**
         * @param {HTMLElement|string} targetElement
         * @param {OverlayOptions} [options]
         */
        constructor(targetElement, options = {}) {
          this.target = typeof targetElement === "string" ? document.querySelector(targetElement) : targetElement;
          if (!this.target) return;
          this.options = {
            backdropClass: "overlay-backdrop",
            bodyClass: "overlay-open",
            backdrop: true,
            keyboard: true,
            static: false,
            useSelfAsBackdrop: false,
            ...options
          };
          this.isOpen = false;
          this.backdrop = null;
          this.closeHandlers = [];
          if (!window.openOverlays) window.openOverlays = /* @__PURE__ */ new Set();
          this.init();
        }
        init() {
          if (this.options.backdrop) {
            this.createBackdrop();
          }
          const closeButtons = this.target.querySelectorAll("[data-dismiss]");
          closeButtons.forEach((btn) => {
            const handler = (e) => {
              e.preventDefault();
              this.hide();
            };
            btn.addEventListener("click", handler);
            this.closeHandlers.push({ element: btn, handler, type: "click" });
          });
          if (this.backdrop) {
            const backdropHandler = (e) => {
              if (this.options.useSelfAsBackdrop) {
                if (e.target === this.target && !this.options.static) {
                  this.hide();
                }
              } else if (e.target === this.backdrop && !this.options.static) {
                this.hide();
              }
            };
            const backdropElement = this.options.useSelfAsBackdrop ? this.target : this.backdrop;
            backdropElement.addEventListener("click", backdropHandler);
            this.closeHandlers.push({ element: backdropElement, handler: backdropHandler, type: "click" });
          }
          if (this.options.keyboard) {
            const escHandler = (e) => {
              if (e.key === "Escape" && this.isOpen && !this.options.static) {
                this.hide();
              }
            };
            document.addEventListener("keydown", escHandler);
            this.closeHandlers.push({ element: document, handler: escHandler, type: "keydown" });
          }
        }
        createBackdrop() {
          if (this.options.useSelfAsBackdrop) {
            this.backdrop = this.target;
          } else {
            this.backdrop = document.querySelector(`.${this.options.backdropClass}`);
            if (!this.backdrop) {
              this.backdrop = document.createElement("div");
              this.backdrop.className = this.options.backdropClass;
              document.body.appendChild(this.backdrop);
            }
          }
        }
        show() {
          if (this.isOpen) return;
          this.isOpen = true;
          this.target.classList.add("show");
          if (this.backdrop && !this.options.useSelfAsBackdrop) {
            this.backdrop.classList.add("show");
            this.backdrop.dataset.activeOverlay = this.target.id || this.target.className;
          }
          document.body.classList.add(this.options.bodyClass);
          document.body.style.overflow = "hidden";
          this.target.dispatchEvent(new CustomEvent("overlay:shown"));
          window.openOverlays.add(this.target);
        }
        hide() {
          if (!this.isOpen) return;
          this.isOpen = false;
          this.target.classList.remove("show");
          if (this.backdrop && !this.options.useSelfAsBackdrop && !this.hasOtherOpenOverlays()) {
            this.backdrop.classList.remove("show");
          }
          if (this.backdrop && !this.options.useSelfAsBackdrop) {
            delete this.backdrop.dataset.activeOverlay;
          }
          const transitionEndHandler = () => {
            this.target.removeEventListener("transitionend", transitionEndHandler);
            if (!this.hasOtherOpenOverlays()) {
              document.body.classList.remove(this.options.bodyClass);
              document.body.style.overflow = "";
            }
            this.target.dispatchEvent(new CustomEvent("overlay:hidden"));
          };
          this.target.addEventListener("transitionend", transitionEndHandler, { once: true });
          setTimeout(() => {
            this.target.removeEventListener("transitionend", transitionEndHandler);
            if (!this.hasOtherOpenOverlays()) {
              document.body.classList.remove(this.options.bodyClass);
              document.body.style.overflow = "";
            }
            this.target.dispatchEvent(new CustomEvent("overlay:hidden"));
          }, 200);
          window.openOverlays.delete(this.target);
        }
        /**
         * Проверяет, есть ли другие открытые overlays
         */
        hasOtherOpenOverlays() {
          return window.openOverlays.size > 1 || window.openOverlays.size === 1 && !window.openOverlays.has(this.target);
        }
        toggle() {
          if (this.isOpen) {
            this.hide();
          } else {
            this.show();
          }
        }
        destroy() {
          this.closeHandlers.forEach(({ element, handler, type }) => {
            element.removeEventListener(type, handler);
          });
          this.closeHandlers = [];
          if (this.backdrop && !this.options.useSelfAsBackdrop && this.backdrop.parentNode) {
            if (!this.backdrop.dataset.activeOverlay) {
              this.backdrop.parentNode.removeChild(this.backdrop);
            }
          }
        }
      };
      OverlayFactory = {
        // Для offcanvas элементов - внешний backdrop
        offcanvas(target) {
          return new Overlay(target, {
            backdropClass: "offcanvas-backdrop",
            bodyClass: "offcanvas-open",
            backdrop: true,
            useSelfAsBackdrop: false
          });
        },
        // Для modal элементов - self-backdrop (использует сам modal как backdrop)
        modal(target) {
          return new Overlay(target, {
            bodyClass: "modal-open",
            backdrop: false,
            useSelfAsBackdrop: true
          });
        },
        // Для modal элементов с внешним backdrop (альтернатива)
        modalWithBackdrop(target) {
          return new Overlay(target, {
            backdropClass: "modal-backdrop",
            bodyClass: "modal-open",
            backdrop: true,
            useSelfAsBackdrop: false
          });
        },
        // Для collapse элементов - без backdrop
        collapse(target) {
          return new Overlay(target, {
            backdrop: false,
            bodyClass: "collapse-open"
          });
        }
      };
    }
  });

  // src/js/components/modal.js
  var modal_exports = {};
  __export(modal_exports, {
    Modal: () => Modal,
    cleanupModals: () => cleanupModals,
    initModals: () => initModals
  });
  function initModals() {
    const triggers = document.querySelectorAll('[data-toggle="modal"]');
    triggers.forEach((trigger) => {
      const targetSelector = trigger.getAttribute("data-target");
      if (!targetSelector) return;
      const target = document.querySelector(targetSelector);
      if (!target) return;
      if (!window.modalInstances.has(targetSelector)) {
        window.modalInstances.set(targetSelector, new Modal(target));
      }
      trigger.addEventListener("click", (e) => {
        e.preventDefault();
        const openData = {
          trigger,
          slideIndex: trigger.hasAttribute("data-slide-index") ? parseInt(trigger.getAttribute("data-slide-index")) : Array.from(document.querySelectorAll(`[data-target="${targetSelector}"]`)).indexOf(trigger)
        };
        window.modalInstances.get(targetSelector)?.open(openData);
      });
    });
  }
  function cleanupModals() {
    if (!window.modalInstances || window.modalInstances.size === 0) return;
    window.modalInstances.forEach((modalInstance) => {
      modalInstance.destroy();
    });
    window.modalInstances.clear();
  }
  var Modal;
  var init_modal = __esm({
    "src/js/components/modal.js"() {
      init_overlay();
      Modal = class {
        /**
         * @param {HTMLElement|string} modalSelector
         * @param {ModalOptions} [options]
         */
        constructor(modalSelector, options = {}) {
          this.modal = typeof modalSelector === "string" ? document.querySelector(modalSelector) : modalSelector;
          if (!this.modal) return;
          const useSelfBackdrop = options.useSelfBackdrop ?? this.modal.hasAttribute("data-self-backdrop") ?? true;
          this.overlay = useSelfBackdrop ? OverlayFactory.modalWithBackdrop(this.modal) : OverlayFactory.modal(this.modal);
          this.isOpen = false;
          this.closeHandlers = [];
          this.initModalSpecific();
          this.initCloseHandlers();
        }
        initModalSpecific() {
          const backdropSetting = this.modal.getAttribute("data-backdrop");
          const isStatic = backdropSetting === "static";
          if (backdropSetting === "false") {
            this.overlay.options.static = true;
          } else {
            this.overlay.options.static = isStatic;
          }
          this.modal.addEventListener("overlay:hidden", () => {
            this.isOpen = false;
            this.modal.dispatchEvent(new CustomEvent("modal:hidden"));
          });
        }
        initCloseHandlers() {
          const closeBtns = this.modal.querySelectorAll('[data-dismiss="modal"]');
          closeBtns.forEach((btn) => {
            const handler = (e) => {
              e.preventDefault();
              this.close();
            };
            btn.addEventListener("click", handler);
            this.closeHandlers.push({ element: btn, handler, type: "click" });
          });
          if (this.overlay.options.useSelfAsBackdrop) {
            const backdropHandler = (e) => {
              if (e.target === this.modal && !this.overlay.options.static) {
                this.close();
              }
            };
            this.modal.addEventListener("click", backdropHandler);
            this.closeHandlers.push({ element: this.modal, handler: backdropHandler, type: "click" });
          }
          const escHandler = (e) => {
            if (e.key === "Escape" && this.isOpen && !this.overlay.options.static) {
              this.close();
            }
          };
          document.addEventListener("keydown", escHandler);
          this.closeHandlers.push({ element: document, handler: escHandler, type: "keydown" });
        }
        open(data = null) {
          if (this.isOpen) return;
          this.overlay.show();
          this.isOpen = true;
          this.modal.dispatchEvent(new CustomEvent("modal:shown", {
            detail: data
          }));
        }
        close() {
          if (!this.isOpen) return;
          this.overlay.hide();
          this.isOpen = false;
          this.modal.dispatchEvent(new CustomEvent("modal:hidden"));
        }
        destroy() {
          this.closeHandlers.forEach(({ element, handler, type }) => {
            element.removeEventListener(type, handler);
          });
          this.closeHandlers = [];
          this.overlay.destroy();
        }
        // Aliases для совместимости
        show() {
          this.open();
        }
        hide() {
          this.close();
        }
        toggle() {
          this.overlay.toggle();
          this.isOpen = !this.isOpen;
        }
      };
    }
  });

  // src/js/components/alert.js
  var Alert = class _Alert {
    constructor(element) {
      this.element = element;
      this.isClosing = false;
      this.ensureCloseButton();
      if (this.element.classList.contains("fade") && !this.element.classList.contains("show")) {
        this.show();
      }
      this.init();
    }
    init() {
      const closeBtn = this.element.querySelector('[data-dismiss="alert"]');
      if (closeBtn) {
        closeBtn.addEventListener("click", (e) => {
          e.preventDefault();
          this.close();
        });
      }
      this.handleEscape = (e) => {
        if (e.key === "Escape") {
          this.close();
        }
      };
      window.addEventListener("keydown", this.handleEscape);
    }
    ensureCloseButton() {
      if (!this.element.querySelector('[data-dismiss="alert"]')) {
        const closeBtn = document.createElement("button");
        closeBtn.type = "button";
        closeBtn.className = "btn-close";
        closeBtn.setAttribute("data-dismiss", "alert");
        closeBtn.setAttribute("aria-label", "Close");
        closeBtn.innerHTML = `
                <svg class="close-icon icon">
                    <use xlink:href="#close-icon"></use>
                </svg>
            `;
        this.element.insertBefore(closeBtn, this.element.firstChild);
      }
    }
    show() {
      setTimeout(() => {
        this.element.classList.add("show");
      }, 10);
    }
    close() {
      if (this.isClosing) return;
      this.isClosing = true;
      const closeEvent = new CustomEvent("alert:close", { bubbles: true });
      this.element.dispatchEvent(closeEvent);
      this.element.classList.remove("show");
      setTimeout(() => {
        const closedEvent = new CustomEvent("alert:closed", { bubbles: true });
        this.element.dispatchEvent(closedEvent);
        this.element.remove();
        window.removeEventListener("keydown", this.handleEscape);
      }, 300);
    }
    static getInstance(element) {
      return element?._alertInstance || null;
    }
    static create(element) {
      if (!element) return null;
      let instance = _Alert.getInstance(element);
      if (!instance) {
        instance = new _Alert(element);
        element._alertInstance = instance;
      }
      return instance;
    }
  };
  function alertHandler(html, options = {}) {
    const config = {
      type: "info",
      duration: 3e3,
      position: "top-right",
      ...options
    };
    const alertElement = document.createElement("div");
    alertElement.className = `alert alert-${config.type} fade ${config.position} box-shadow`;
    alertElement.setAttribute("role", "alert");
    alertElement.innerHTML = `
        <button type="button" class="btn-close bn-md" data-dismiss="alert" aria-label="\u0417\u0430\u043A\u0440\u044B\u0442\u044C">
            <svg class="close-icon icon">
                <use xlink:href="#close-icon"></use>
            </svg>
        </button>
        <div class="alert-body">${html}</div>
    `;
    document.body.appendChild(alertElement);
    const alertInstance = Alert.create(alertElement);
    if (config.duration > 0) {
      setTimeout(() => {
        alertInstance.close();
      }, config.duration);
    }
    return alertInstance;
  }
  var AlertManager = {
    /**
     * @param {string} html - HTML-содержимое
     * @param {number} duration - Время автоматического закрытия
     * @param {string} position - Позиция на экране
     */
    success: (html, duration = 5e3, position = "top-center") => alertHandler(html, { type: "success", duration, position }),
    /**
     * @param {string} html - HTML-содержимое
     * @param {number} duration - Время автоматического закрытия
     * @param {string} position - Позиция на экране
     */
    warning: (html, duration = 5e3, position = "top-center") => alertHandler(html, { type: "warning", duration, position }),
    /**
     * @param {string} html - HTML-содержимое
     * @param {number} duration - Время автоматического закрытия
     * @param {string} position - Позиция на экране
     */
    error: (html, duration = 0, position = "top-center") => alertHandler(html, { type: "error", duration, position }),
    /**
     * @param {string} html - HTML-содержимое
     * @param {number} duration - Время автоматического закрытия
     * @param {string} position - Позиция на экране
     */
    info: (html, duration = 5e3, position = "top-center") => alertHandler(html, { type: "info", duration, position }),
    /**
     * @param {string} html - HTML-содержимое
     * @param {number} duration - Время автоматического закрытия
     * @param {string} position - Позиция на экране
     */
    danger: (html, duration = 0, position = "top-center") => alertHandler(html, { type: "danger", duration, position }),
    /**
     * @param {string} html - HTML-содержимое
     * @param {number} duration - Время автоматического закрытия
     * @param {string} position - Позиция на экране
     */
    primary: (html, duration = 5e3, position = "top-center") => alertHandler(html, { type: "primary", duration, position }),
    /**
     * @param {string} html - HTML-содержимое
     * @param {number} duration - Время автоматического закрытия
     * @param {string} position - Позиция на экране
     */
    light: (html, duration = 3e3, position = "bottom-center") => alertHandler(html, { type: "light", duration, position })
  };

  // src/js/components/offcanvas.js
  init_overlay();
  var Offcanvas = class {
    constructor(offcanvasSelector) {
      this.offcanvas = typeof offcanvasSelector === "string" ? document.querySelector(offcanvasSelector) : offcanvasSelector;
      if (!this.offcanvas) return;
      this.overlay = OverlayFactory.offcanvas(this.offcanvas);
      this.isOpen = false;
      this.closeHandlers = [];
      this.init();
    }
    init() {
      const closeBtns = this.offcanvas.querySelectorAll('[data-dismiss="offcanvas"]');
      closeBtns.forEach((btn) => {
        const handler = (e) => {
          e.preventDefault();
          this.hide();
        };
        btn.addEventListener("click", handler);
        this.closeHandlers.push({ element: btn, handler, type: "click" });
      });
      const escHandler = (e) => {
        if (e.key === "Escape" && this.isOpen) {
          this.hide();
        }
      };
      document.addEventListener("keydown", escHandler);
      this.closeHandlers.push({ element: document, handler: escHandler, type: "keydown" });
    }
    show() {
      this.overlay.show();
      this.isOpen = true;
    }
    hide() {
      this.overlay.hide();
      this.isOpen = false;
    }
    toggle() {
      this.overlay.toggle();
      this.isOpen = !this.isOpen;
    }
    destroy() {
      this.closeHandlers.forEach(({ element, handler, type }) => {
        element.removeEventListener(type, handler);
      });
      this.closeHandlers = [];
      this.overlay.destroy();
    }
  };

  // src/js/components/accordion.js
  var Accordion = class {
    constructor(element) {
      this.element = element;
      this.id = element.dataset.accordionId || element.querySelector("h3, h2")?.textContent?.trim() || "accordion-" + Math.random().toString(36).substring(2, 9);
      this.init();
    }
    init() {
      const children = Array.from(this.element.children);
      this.header = children.find((el) => !el.hasAttribute("data-static"));
      this.content = children.filter(
        (el) => el !== this.header && !el.hasAttribute("data-static")
      );
      if (!this.header || !this.content.length) return;
      const savedState = sessionStorage.getItem(this.id);
      this.isExpanded = savedState === "expanded" || this.element.dataset.accordion === "expanded";
      this.element.dataset.accordion = this.isExpanded ? "expanded" : "collapsed";
      this.updateHeight();
      this.header.addEventListener("click", (e) => this.toggle(e));
    }
    toggle(e) {
      if (e.target.closest("a, [data-static]")) return;
      e.preventDefault();
      this.isExpanded = !this.isExpanded;
      this.element.dataset.accordion = this.isExpanded ? "expanded" : "collapsed";
      this.updateHeight();
      sessionStorage.setItem(this.id, this.isExpanded ? "expanded" : "collapsed");
    }
    updateHeight() {
      this.content.forEach((el) => {
        el.style.height = this.isExpanded ? el.scrollHeight + "px" : "0";
        el.style.opacity = this.isExpanded ? "1" : "0";
      });
    }
  };

  // src/js/utils/viewport.js
  function smoothScroll(pos, offset = 0) {
    window.scrollTo({
      top: pos - offset,
      behavior: "smooth"
    });
  }

  // src/js/utils/common.js
  function rafThrottle(func) {
    let ticking = false;
    return function(...args) {
      if (!ticking) {
        requestAnimationFrame(() => {
          func.apply(this, args);
          ticking = false;
        });
        ticking = true;
      }
    };
  }

  // src/js/components/init.js
  function initComponents() {
    let scrollDown = document.querySelector(".scroll-down");
    const scrollUp = document.querySelector("#back2top");
    const searchContainer = document.querySelector("#searchContainer");
    const handleScroll = rafThrottle(() => {
      const scrollY = window.scrollY;
      const viewportHeight = window.innerHeight;
      if (scrollDown && scrollY >= viewportHeight) {
        scrollDown.remove();
        scrollDown = null;
      }
      if (scrollUp) {
        const shouldShow = scrollY > viewportHeight;
        scrollUp.classList.toggle("disable", !shouldShow);
        scrollUp.style.transform = shouldShow ? "translateY(0)" : "translateY(4vh)";
      }
      if (searchContainer?.classList.contains("active")) {
        searchContainer.classList.remove("active");
      }
    });
    document.addEventListener("scroll", handleScroll, { passive: true });
    const loadingElements = document.querySelectorAll(".loading");
    loadingElements.forEach((item) => {
      item.classList.remove("loading");
      item.classList.add("loaded");
    });
    scrollUp?.addEventListener("click", (e) => {
      e.preventDefault();
      smoothScroll(0, 0);
    });
    scrollDown?.addEventListener("click", (e) => {
      e.preventDefault();
      smoothScroll(0, -window.innerHeight);
    });
    initOffcanvases();
    initSearch();
    initAlerts();
    initAccordions();
  }
  function initOffcanvases() {
    const triggers = document.querySelectorAll('[data-toggle="offcanvas"]');
    triggers.forEach((trigger) => {
      const targetSelector = trigger.getAttribute("data-target");
      if (!targetSelector) return;
      const target = document.querySelector(targetSelector);
      if (!target) return;
      trigger.addEventListener("click", (e) => {
        e.preventDefault();
        new Offcanvas(target).toggle();
      });
    });
  }
  function initAlerts() {
    const alerts = document.querySelectorAll(".alert");
    alerts.forEach((alert2) => {
      Alert.create(alert2);
    });
  }
  function initSearch() {
    const searchContainer = document.querySelector("#searchContainer");
    if (!searchContainer) return;
    const searchInput = searchContainer.querySelector("[type=search]");
    const clearInput = searchContainer.querySelector(".clear-input");
    const searchLinks = document.querySelectorAll(".nav-search-link");
    searchLinks.forEach((item) => {
      item.addEventListener("click", (e) => {
        e.preventDefault();
        searchContainer.classList.toggle("active");
        if (searchContainer.classList.contains("active")) {
          if (searchInput.value) {
            clearInput?.classList.add("show");
          }
          searchInput.focus();
        } else {
          searchInput.blur();
        }
      });
    });
    clearInput?.addEventListener("click", () => {
      searchInput.value = "";
      searchInput.focus();
      clearInput.classList.remove("show");
    });
    searchInput?.addEventListener("input", (e) => {
      if (e.target.value.length > 0) {
        clearInput?.classList.add("show");
      } else {
        clearInput?.classList.remove("show");
      }
    });
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && searchContainer.classList.contains("active")) {
        searchContainer.classList.remove("active");
      }
    });
  }
  function initAccordions() {
    document.querySelectorAll("[data-accordion]").forEach((el) => new Accordion(el));
  }

  // src/js/components/navbar.js
  var Navbar = class {
    constructor(navbarElement) {
      this.navbar = navbarElement;
      if (!this.navbar) return;
      this.menu = document.querySelector("#navbarMenu");
      this.menuOffcanvas = this.menu ? new Offcanvas(this.menu) : null;
      this.init();
    }
    init() {
      navbarOffset(this.navbar);
      this.initNavLinks();
      initExhibitionsMenu();
      this.initResizeHandler();
    }
    initNavLinks() {
      const navLinks = document.querySelectorAll("a.nav-link:not(.dropdown-toggle)");
      navLinks.forEach((link) => {
        link.addEventListener("click", () => {
          if (window.innerWidth < 992 && this.menuOffcanvas) {
            this.menuOffcanvas.hide();
          }
        });
      });
    }
    initResizeHandler() {
      window.addEventListener("resize", () => {
        if (window.innerWidth >= 992) {
          const isDesignerPage = document.documentElement.classList.contains("designer-page") || document.body.classList.contains("designer-page");
          if (!isDesignerPage && this.menuOffcanvas && this.menu.classList.contains("show")) {
            this.menuOffcanvas.hide();
          }
          navbarOffset(this.navbar);
        }
      });
    }
  };
  function initExhibitionsMenu() {
    const exhibitionsLink = document.getElementById("exhibitionsMenuLink");
    const dropdownList = document.getElementById("dropdownYearsList");
    if (!exhibitionsLink || !dropdownList) return;
    exhibitionsLink.addEventListener("click", (e) => {
      if (window.innerWidth < 992) {
        e.preventDefault();
        const isNotExpanded = (exhibitionsLink.getAttribute("aria-expanded") !== "true").toString();
        exhibitionsLink.setAttribute("aria-expanded", isNotExpanded);
        if (isNotExpanded) {
          dropdownList.classList.add("show");
          dropdownList.classList.remove("collapse");
        } else {
          dropdownList.classList.remove("show");
          dropdownList.classList.add("collapse");
        }
      }
    });
  }
  function navbarOffset(elem) {
    if (!elem) return;
    const navHeight = elem.clientHeight;
    const header = elem.nextElementSibling;
    if (header) {
      header.style.marginTop = navHeight + "px";
      const headerHeight = header.clientHeight;
      const container = header.nextElementSibling;
      if (container) {
        container.style.minHeight = `calc(100vh - ${navHeight}px - ${headerHeight}px)`;
      }
    }
  }

  // src/js/utils/lazyload.js
  function loadImage(img) {
    if (img.complete && img.naturalHeight !== 0) {
      img.classList.add("lazyloaded");
      img.classList.remove("lazyload");
      if (img.dataset.src) img.removeAttribute("data-src");
      if (img.dataset.srcset) img.removeAttribute("data-srcset");
      return Promise.resolve();
    }
    return new Promise((resolve, reject) => {
      img.onload = function() {
        img.classList.add("lazyloaded");
        img.classList.remove("lazyload");
        if (img.dataset.src) img.removeAttribute("data-src");
        if (img.dataset.srcset) img.removeAttribute("data-srcset");
        resolve();
      };
      img.onerror = function() {
        img.classList.add("lazyerror");
        img.classList.remove("lazyload");
        console.warn("Failed to load image:", img.src || img.dataset.src);
        reject(new Error("Image load failed"));
      };
    });
  }
  function initImageLoad(img) {
    if (img.dataset.src) {
      if (!img.src || img.src !== img.dataset.src) {
        img.src = img.dataset.src;
      }
    }
    if (img.dataset.srcset) {
      if (!img.srcset || img.srcset !== img.dataset.srcset) {
        img.srcset = img.dataset.srcset;
      }
    }
    if ("loading" in HTMLImageElement.prototype && !img.hasAttribute("loading")) {
      img.setAttribute("loading", "lazy");
    }
    return loadImage(img);
  }
  function lazyloadInit() {
    const images = document.querySelectorAll("img.lazyload:not(.lazyloaded)");
    if (images.length === 0) {
      return;
    }
    images.forEach((img) => {
      if (img.src && !img.dataset.src && img.complete && img.naturalHeight !== 0) {
        img.classList.add("lazyloaded");
        img.classList.remove("lazyload");
      }
    });
    if ("IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype) {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.intersectionRatio > 0) {
            const img = entry.target;
            initImageLoad(img).catch(() => {
            });
            observer.unobserve(img);
          }
        });
      }, {
        // Загружаем изображения немного раньше чем они появятся на экране
        rootMargin: "50px 0px",
        threshold: 0.01
      });
      images.forEach((img) => {
        observer.observe(img);
      });
    } else {
      images.forEach((img) => {
        initImageLoad(img).catch(() => {
        });
      });
    }
  }

  // src/js/utils/ajax.js
  function ajaxSend(url, params = "", method = "post", renderFunc = defaultRender, showAlert = false) {
    const requestUrl = method.toLowerCase() === "get" ? `${url}?${params}` : url;
    const requestConfig = {
      method,
      headers: {
        "X-Requested-With": "XMLHttpRequest"
      }
    };
    if (method.toLowerCase() === "post") {
      requestConfig.headers["Content-Type"] = "application/x-www-form-urlencoded";
      requestConfig.body = params;
    }
    fetch(requestUrl, requestConfig).then((response) => {
      if (!response.ok) {
        throw new Error(`\u274C HTTP error!
status: ${response.status}`);
      }
      return response.json();
    }).then((json) => {
      if (typeof renderFunc === "function") {
        renderFunc(json);
      } else {
        console.warn("\u274C Render function not provided", json);
        defaultRender(json);
      }
    }).catch((error) => {
      console.error("\u274C AJAX Error:", error);
      if (showAlert) {
        const errorMessage = getErrorMessage(error);
        showGlobalError(errorMessage);
      }
    });
  }
  function getErrorMessage(error) {
    if (error.name === "TypeError" && error.message.includes("Failed to fetch")) {
      return "\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u0435\u0442\u0438: \u043D\u0435\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0438\u0442\u044C\u0441\u044F \u043A \u0441\u0435\u0440\u0432\u0435\u0440\u0443";
    } else if (error.message.includes("HTTP error! status: 403")) {
      return "\u0423 \u0432\u0430\u0441 \u043D\u0435\u0442 \u043F\u0440\u0430\u0432 \u0434\u043B\u044F \u044D\u0442\u043E\u0433\u043E \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F";
    } else if (error.message.includes("HTTP error! status: 404")) {
      return "\u0421\u0442\u0440\u0430\u043D\u0438\u0446\u0430 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u0430";
    } else if (error.message.includes("HTTP error")) {
      return `\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: ${error.status}`;
    } else if (error.message.includes("\u0414\u043E\u0441\u0442\u0443\u043F \u0437\u0430\u043F\u0440\u0435\u0449\u0435\u043D")) {
      return "\u0423 \u0432\u0430\u0441 \u043D\u0435\u0442 \u043F\u0440\u0430\u0432 \u0434\u043B\u044F \u044D\u0442\u043E\u0433\u043E \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044F";
    } else {
      return error.message || "\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430";
    }
  }
  function showGlobalError(message) {
    if (window.Alert) {
      window.Alert.error(`<h3>\u041E\u0448\u0438\u0431\u043A\u0430!</h3><p>${message}</p>`);
    } else {
      alert(`\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0430: ${message}`);
    }
  }
  function defaultRender(json) {
    if (json.message && window.Alert) {
      const messageType = json.status === "error" ? "error" : "success";
      window.Alert[messageType]?.(json.message);
    }
  }

  // src/js/base.js
  document.addEventListener("DOMContentLoaded", async () => {
    initComponents();
    const navbarElement = document.querySelector(".navbar");
    if (navbarElement) {
      new Navbar(navbarElement);
    }
    if (document.querySelector(".modal")) {
      window.modalInstances = /* @__PURE__ */ new Map();
      const { initModals: initModals2, cleanupModals: cleanupModals2 } = await Promise.resolve().then(() => (init_modal(), modal_exports));
      initModals2();
      window.addEventListener("beforeunload", cleanupModals2);
    }
    window.ajaxSend = ajaxSend;
    window.Alert = AlertManager;
    lazyloadInit();
    if ("loading" in HTMLImageElement.prototype) {
      const images = document.querySelectorAll("img:not(.lazyload)");
      images.forEach((img) => {
        if (img.dataset.src) {
          img.src = img.dataset.src;
          img.removeAttribute("data-src");
        }
        if (img.dataset.srcset) {
          img.srcset = img.dataset.srcset;
          img.removeAttribute("data-srcset");
        }
        if (img.complete && img.naturalHeight !== 0) {
          img.classList.add("lazyloaded");
        }
      });
    }
  });
})();
//# sourceMappingURL=base.min.js.map
